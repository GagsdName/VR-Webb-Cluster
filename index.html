<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR boilerplate</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="stylesheet" href="src/css/main.css">
</head>

<body>
<!--[if lt IE 10]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <div id="ui">
            Show stars visible from Earth?
            <input type="checkbox" id="visible" checked><br>
            Show cluster stars?
            <input type="checkbox" id="cluster" checked><br>
            Rotate?
            <input type="checkbox" id="rotate"><br>
            Free-fly?
            <input type="checkbox" id="freefly"><br>
            <h3>Field of View</h3>
            <form id="fov">
                <input type="radio" name="fov" id="fovHuman" value="human">Human FOV<br>
                <input type="radio" name="fov" id="fovWide" value="wide" checked>Wide FOV
            </form>

            <h3>Position</h3>
            <form id="position">
                <input type="radio" name="position" id="flyTo0" value="0" checked>(0, 0, 0)<br>
                <input type="radio" name="position" id="flyTo5" value="5">(0, 0, 5pc)<br>
                <input type="radio" name="position" id="flyTo10" value="10">(0, 0, 10pc)
            </form>
        </div>
		
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.1.1/chroma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
<script src="src/js/vendor/three.min.js"></script>
<script src="src/js/vendor/TweenLite.min.js"></script>
<script src="src/js/vendor/MouseControls.js"></script>
<script src="src/js/controls/DeviceOrientationControls.js"></script>
<script src="src/js/effects/StereoEffect.js"></script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="node_modules/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>

<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
 <script>
(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-XXXXX-X');ga('send','pageview');
</script>

<script>
		(function() {

var scene,
    camera,
    renderer,
	effect,
	params,
	manager,
    //colorScale,
    colorScaleRed,
    colorScaleWhite,
    colorScaleBlue,
    controls,
    visibles,
    visibleParticles,
    clusters,
    clusterParticles,
    checkRotate,
    checkVisible,
    checkCluster,
    radioFovHuman,
    radioFovWide,
    FOV_HUMAN = 27,
    FOV_WIDE = 75,
    ROTATE_ANGLE_HUMAN = 0.001,
    ROTATE_ANGLE_WIDE = 0.003,
    ROTATE_AXIS = new THREE.Vector3(1, 0, 0),
    rotateAngle,
    radioFlyTo0,
    radioFlyTo5,
    radioFlyTo10;

init();

animate();

Papa.parse('src/data/movie.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
        createGeometry(results.data, 'cluster');
    }
});

Papa.parse('src/data/visible.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
        createGeometry(results.data, 'visible');
    }
});



function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(FOV_WIDE,
                                         window.innerWidth / window.innerHeight,
                                         0.1,
                                         20000);

    rotateAngle = ROTATE_ANGLE_HUMAN;
    //camera.setLens(300);

    renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    

     // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
	//alert(effect);
    effect.setSize(window.innerWidth, window.innerHeight);	
   
   // effect = new THREE.StereoEffect( renderer );
	//alert(effect);
	//effect.setSize( window.innerWidth, window.innerHeight );
	
	// Create a VR manager helper to enter and exit VR mode.
    params = {
    hideButton: false, // Default: false.
    isUndistorted: false // Default: false.
    };

	 manager = new WebVRManager(renderer, effect, params);
	//alert(manager);
	
	// Apply VR headset positional data to camera.
    controls = new THREE.VRControls(camera);
    /*var freefly = document.getElementbyId('freefly');
	alert(freefly);
	if(freefly.checked)
	{controls.standing = true; controls.update();}*/

    document.body.appendChild( renderer.domElement );

	// Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          //controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);
		
	
    /*colorScale = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);*/

    colorScaleRed = chroma.scale(['lightyellow', 'peachpuff', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleWhite = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleBlue = chroma.scale(['lightcyan', 'lightsteelblue', 'black'])
        .domain([-9, -1, 6.5]);

    checkRotate = document.getElementById('rotate');
    checkVisible = document.getElementById('visible');
    checkCluster = document.getElementById('cluster');
    radioFovHuman = document.getElementById('fovHuman');
    radioFovWide = document.getElementById('fovWide');
    radioFlyTo0 = document.getElementById('flyTo0');
    radioFlyTo5 = document.getElementById('flyTo5');
    radioFlyTo10 = document.getElementById('flyTo10');

    checkVisible.addEventListener('click', function() {
        visibleParticles.visible = checkVisible.checked;
    });

    checkCluster.addEventListener('click', function() {
        clusterParticles.visible = checkCluster.checked;
    });

    radioFovHuman.addEventListener('click', function() {
        TweenLite.to(camera, 1, {fov: FOV_HUMAN, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_HUMAN;
        }});
    });

    radioFovWide.addEventListener('click', function() {
        TweenLite.to(camera, 1, {fov: FOV_WIDE, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_WIDE;
        }});
    });

    radioFlyTo0.addEventListener('click', function() {
        flyTo(new THREE.Vector3(0, 0, 0));
    });

    radioFlyTo5.addEventListener('click', function() {
        flyTo(new THREE.Vector3(0, 0, 5));
    });

    radioFlyTo10.addEventListener('click', function() {
        flyTo(new THREE.Vector3(0, 0, 10));
    });
}

function createGeometry(data, name) {
    var geometry = new THREE.Geometry(),
        size = 2,
        material,
        particles,
        color;


		
    for (var i = 0; i < data.length; i++) {
        var vertex = new THREE.Vector3();
        vertex.x = data[i].X;
        vertex.y = data[i].Y;
        vertex.z = data[i].Z;
        geometry.vertices.push( vertex );

        color = calculateColor(data[i]);
        geometry.colors.push( color );
    }


    material = new THREE.PointsMaterial({
        size: size,
        sizeAttenuation: false,
        vertexColors: THREE.VertexColors
    });
    particles = new THREE.Points( geometry, material );
    particles.name = name;
    scene.add( particles );

    if (name === 'visible') {
        visibles = data;
        visibleParticles = particles;
    } else if (name === 'cluster') {
        clusters = data;
        clusterParticles = particles;
    }
}

function animate() {

    requestAnimationFrame( animate );

    controls.update();

    render();
}

function render() {
    if (checkRotate.checked) {
        visibleParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
        clusterParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
    }

    effect.render(scene, camera);
}

/**
 * Calculate the apparent magnitude and color mapping of the star
 * @param star
 */
function calculateColor(star) {
    var distance = {}, m, color;

    distance.x = star.X - camera.position.x;
    distance.y = star.Y - camera.position.y;
    distance.z = star.Z - camera.position.z;
    distance.total = Math.sqrt(Math.pow(distance.x, 2) +
                               Math.pow(distance.y, 2) +
                               Math.pow(distance.z, 2));

    m = star.M - 5 * (1 - Math.log10(distance.total));

    //color = colorScale(m).gl();

    if (star.T < 4000) {
        color = colorScaleRed(m).gl();
    } else if (star.T > 10000) {
        color = colorScaleBlue(m).gl();
    } else {
        color = colorScaleWhite(m).gl();
    }

    return new THREE.Color(color[0], color[1], color[2]);
}

/**
 * Move camera to the given location
 * @param location
 */
function flyTo(location) {
    // fly to new position
    var oldPosition = camera.position;
    camera.position.set(location.x, location.y, location.z);

    // calculate new m and colors
    /*for (var i = 0, l = visibleParticles.geometry.colors.length; i < l; i++) {
        visibleParticles.geometry.colors[i] = calculateColor(visibles[i]);
    }*/

    for (var j = 0, m = clusterParticles.geometry.colors.length; j < m; j++) {
        clusterParticles.geometry.colors[j] = calculateColor(clusters[j]);
    }

    visibleParticles.geometry.colorsNeedUpdate = true;
    clusterParticles.geometry.colorsNeedUpdate = true;

    // set new rotation origin
    visibleParticles.position.set(location.x, location.y, location.z);
    /*visibleParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);*/

    clusterParticles.position.set(location.x, location.y, location.z);
    clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);
}

})();

		</script>
	


</html>
