<!DOCTYPE html>

<html lang="en">
<head>
<title>Webb-Cluster</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="stylesheet" href="src/css/main.css">
	

</head>

<body>

<!--[if lt IE 10]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
<div id="progress">
			<span id="message">Loading ...</span>

			<center>
				<div id="progressbar" class="shadow"><div id="bar" class="shadow"></div></div>
			</center>
		</div>

<div id= "controls">

</div>	  
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.1.1/chroma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
<script src="src/js/vendor/three.min.js"></script>
<script src="src/js/vendor/TweenLite.min.js"></script>


<script src="src/js/controls/DeviceOrientationControls.js"></script>
<script src="src/js/effects/StereoEffect.js"></script>

<script src="src/js/stats.js"></script>
<script src="src/js/DAT.gui.js"></script>
<!--<script src="src/js/THREEx.KeyboardState.js"></script>
-->

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */
  //CARDBOARD_UI_DISABLED: false,
  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
	<script src="node_modules/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>


<script src="node_modules/three/examples/js/materials/ShadowMaterial.js"></script>

<script src="node_modules/three/examples/js/controls/TrackballControls.js"></script>
<script src="src/js/reticulum.js"></script>
<script src='src/js/threex.htmlmixer.js'></script>
<script src='src/js/CSS3DRenderer.js'></script>
<!--
<script src="src/js/gentilis_bold.typeface.js"></script>
<script src="src/js/gentilis_regular.typeface.js"></script>
<script src="src/js/optimer_bold.typeface.js"></script>
<script src="src/js/optimer_regular.typeface.js"></script>
<script src="src/js/helvetiker_bold.typeface.js"></script>
<script src="src/js/helvetiker_regular.typeface.js"></script>
<script src="src/js/droid_sans_regular.typeface.js"></script>
<script src="src/js/droid_sans_bold.typeface.js"></script>
<script src="src/js/droid_serif_bold.typeface.js"></script>
<script src="src/js/droid_serif_regular.typeface.js"></script>
-->

<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
</script>
<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
 <script>
(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-XXXXX-X');ga('send','pageview');
</script>

<script>
		(function() {

var scene,
    camera,
    renderer,
	effect,
	stats,
	gui,
	rotationToggle,clusterToggle,visibleToggle,fovToggle,positionToggle,
	params,
	platform,
	skybox,
	mixerContext,
	manager,
	uniforms,
    cameraControls,
    //colorScale,
    colorScaleRed,
    colorScaleWhite,
    colorScaleBlue,
    controls,
	loadrotationToggle,
    visibles,
    visibleParticles,
    clusters,
    clusterParticles,
    checkRotate = false,
    FOV_HUMAN = 27,
    FOV_WIDE = 75,
    ROTATE_ANGLE_HUMAN = 0.001,
    ROTATE_ANGLE_WIDE = 0.003,
    ROTATE_AXIS = new THREE.Vector3(1, 0, 0),
    rotateAngle,
	complete = false,
	total,
	loaded,raycaster,crosshair,
    bar = 100,
	loadFin = false;
	//keyboard = new THREEx.KeyboardState();
	

var clock = new THREE.Clock();

init();

animate();
total = 0, loaded = 0;
Papa.parse('src/data/movie.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
	
        createGeometry(results.data, 'cluster');
    }
});

Papa.parse('src/data/visible.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
        createGeometry(results.data, 'visible');
    }
});


	
	
 function loadingFinished( ) {
	loadFin = true;
	document.getElementById( "message" ).style.display = "none";
	document.getElementById( "progressbar" ).style.display = "none";
	document.getElementById( "progress" ).style.display = "none";
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

}

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(FOV_WIDE,
                                         window.innerWidth / window.innerHeight,
                                         0.1,
                                         20000);

    rotateAngle = ROTATE_ANGLE_HUMAN;
	var mixerContext= new THREEx.HtmlMixer.Context(renderer, scene, camera);
	alert(mixerContext);
// *******************************
// --- Reticulum ---
// initiate Reticulum so it loads up 
Reticulum.init(camera, {
	proximity: false,
	clickevents: true,
	reticle: {
		visible: true,
		restPoint: 1000, //Defines the reticle's resting point when no object has been targeted
		color: 0xcc0000,
		innerRadius: 0.001,
		outerRadius: 0.003,
		hover: {
			color: 0xcc0000,
			innerRadius: 0.02,
			outerRadius: 0.024,
			speed: 5,
			vibrate: 50 //Set to 0 or [] to disable
		}
	},
	fuse: {
		visible: false,
		duration: 2.5,
		color: 0x00fff6,
		innerRadius: 0.045,
		outerRadius: 0.06,
		vibrate: 100, //Set to 0 or [] to disable
		clickCancelFuse: false //If users clicks on targeted object fuse is canceled
	}
});

// IMPORTANT add camera to cene if you want to see a reticle 
scene.add(camera);
  
	//camera.position.set(0,6,0);
 	//camera.position.y = 200000;
    //camera.setLens(12);

   
    renderer = new THREE.WebGLRenderer({antialias: true });
	renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    //renderer.sortObjects = true;

     // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
	//alert(effect);
    effect.setSize(window.innerWidth, window.innerHeight);	
   
 


document.getElementById( "progress" ).style.display = "block";
			
			
			
				
	
	// Create a VR manager helper to enter and exit VR mode.
    params = {
    hideButton: false, // Default: false.
    isUndistorted: false // Default: false.
    };

	 manager = new WebVRManager(renderer, effect, params);

	// Apply VR headset positional data to camera.
    controls = new THREE.VRControls(camera);
	//controls.standing = true;
	
    stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	  document.body.appendChild( stats.domElement );
	  
     //////////////////////
	// GUI Toggle-Panel //
	/////////////////////
	
	gui = new dat.GUI();
    document.getElementById('controls').appendChild(gui.domElement);
	document.getElementById('controls').style.display = 'block';
	parameters = 
	{ se: true, cs: true, mv: false, plt: false, rot: false, sky: true, hfov: false, wfov: true, zz: true, z5: false, z10: false,  color: "#ffff00" };
	

	 
	var folder1 = gui.addFolder('Toggle Features');
	
	var seGUI = folder1.add( parameters, 'se' ).name("Earth visible stars").listen();
	seGUI.onChange( function(value) { 
	 visibleParticles.visible = value;
		if (value == false)visibleToggle.material.color.setHex(0xd62d20);
			
			else visibleToggle.material.color.setHex(0x008744);
	});
	var csGUI = folder1.add( parameters, 'cs' ).name("Cluster stars").listen();
	csGUI.onChange( function(value) { 
	clusterParticles.visible = value;
		        
			if (value == false)clusterToggle.material.color.setHex(0xd62d20);
			
			else clusterToggle.material.color.setHex(0x008744);
	});
	
    var rotGUI = folder1.add( parameters, 'rot' ).name("Rotate").listen();
	rotGUI.onChange( function(value) { 
	  checkRotate = value;
	        
			if (value == false)rotationToggle.material.color.setHex(0xd62d20);
			
			else rotationToggle.material.color.setHex(0x008744);

	});
	
	var skyGUI = folder1.add( parameters, 'sky' ).name("Skybox").listen();
	skyGUI.onChange( function(value) { 
	  skybox.visible = value;
	
	});
	/*var mvGUI = folder1.add( parameters, 'mv' ).name("Earth").listen();
	mvGUI.onChange( function(value) { 
	earthMesh.visible = value;
	
	});
	*/
	/*var pltGUI = folder1.add( parameters, 'plt' ).name("Platform").listen();
	pltGUI.onChange( function(value) { 
	platform.visible = value;
	
	
	});
 */
	
	var folder2 = gui.addFolder('Toggle Field of View');
	var hfovGUI = folder2.add( parameters, 'hfov' ).name("Human View").listen();
	hfovGUI.onChange( function(value) { 
	parameters.wfov = false;
	parameters.hfov = true;
	fovToggle.material.color.setHex(0xd62d20);
 
	TweenLite.to(camera, 1, {fov: FOV_HUMAN, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_HUMAN;
        }});
	
	});
	
	var wfovGUI = folder2.add( parameters, 'wfov' ).name("Wide View").listen();
	wfovGUI.onChange( function(value) { 
	
	parameters.hfov = false;
	parameters.wfov = true;
	fovToggle.material.color.setHex(0x008744);
	
	TweenLite.to(camera, 1, {fov: FOV_WIDE, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_WIDE;
        }});
	
	});
	


	
	
	var folder3 = gui.addFolder('Toggle Position');
	var zzGUI = folder3.add( parameters, 'zz' ).name("(0 0 0)").listen();
	zzGUI.onChange( function(value) { 
	  parameters.zz = true;
      parameters.z5 = false;
	  parameters.z10 = false;
	  	  positionToggle.material.color.setHex(0xb3cde0);

	  flyTo(new THREE.Vector3(0, 0, 0));
	  
	});
	
	var z5 = folder3.add( parameters, 'z5' ).name("(0,0,5 pc)").listen();
	z5.onChange( function(value) { 
	  parameters.zz = false;
      parameters.z5 = true;
	  parameters.z10 = false;
	 	  positionToggle.material.color.setHex(0x6497b1);
	  flyTo(new THREE.Vector3(0, 0, 5));
	});
	
	var z10 = folder3.add( parameters, 'z10' ).name("(0,0,10 pc)").listen();
	z10.onChange( function(value) { 
	 parameters.zz = false;
      parameters.z5 = false;
	  parameters.z10 = true;
	   positionToggle.material.color.setHex(0x005b96);

	  flyTo(new THREE.Vector3(0, 0, 10));
	});
	
    var geometry = new THREE.SphereGeometry(500,60,40);

	var material = new THREE.MeshBasicMaterial();
    material.map = THREE.ImageUtils.loadTexture('src/images/360-2.jpg');
    material.side = THREE.BackSide;
   skybox = new THREE.Mesh(geometry, material);
  //skybox.position.set(0,0,-400);
   skybox.scale.set(6,6,6);
   scene.add(skybox);
   skybox.visible = true;
	

    var helper = new THREE.GridHelper( 30, 10, 0x0000ff,  0x0000ff );
				helper.position.y = - 50;
				
    // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( helper, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,
		onGazeLong: function(){
			if((rotationToggle.visible) || (clusterToggle.visible) || (visibleToggle.visible) || (fovToggle.visible) || (positionToggle.visible) )
			{
			    rotationToggle.visible = false;
				clusterToggle.visible = false;
				visibleToggle.visible = false;
				fovToggle.visible = false;
				positionToggle.visible = false;
			
			
			}
			
			else{
			 rotationToggle.visible = true;
				clusterToggle.visible = true;
				visibleToggle.visible = true;
				fovToggle.visible = true;
				positionToggle.visible = true;
			
			}
			
			// do something user targets object for specific time
			
		}
		
	});
	
	
	scene.add( helper );

		
	var textureLoader = new THREE.TextureLoader();
/*
    var earth = textureLoader.load( 'src/images/earthmap1k.jpg' );

	earthMesh = new THREE.Mesh(
					new THREE.SphereBufferGeometry(0.5, 32, 32 ),
					new THREE.MeshBasicMaterial( {wireframe:true} )
				);

	earthMesh.position.set(0, 0, 0);
    //scene.add( earthMesh );
    earthMesh.visible=false;


	
	function makePlatform( jsonUrl, textureUrl, textureQuality ) {
				var placeholder = new THREE.Object3D();

				var texture = new THREE.TextureLoader().load( textureUrl );
				texture.minFilter = THREE.LinearFilter;
				texture.anisotropy = textureQuality;

				var loader = new THREE.JSONLoader();
				loader.load( jsonUrl, function( geometry ) {

			    geometry.computeFaceNormals();
                //geometry.applyMatrix( new THREE.Matrix4().makeTranslation(0, 0, 60) );
			    platform = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({ map : texture }) );
				//platform.renderOrder = 100;
                    //platform.position = new THREE.Vector3(0, -30, 0)
					//platform.material.polygonOffset = true;
                    //platform.material.polygonOffsetFactor = -0.1;
					//platform.position = new THREE.Vector3(0,0,1000) ; //see position is Vector3()
               platform.position.set(0, -2, 0);
			   //platform.translateZ();
               //clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        //oldPosition.y - location.y,
                                        //oldPosition.z - location.z);
          
					
					platform.name = "platform";

					placeholder.add( platform );
				    platform.visible = false;
					//placeholder.position = new THREE.Vector3(0,0,-10000);
				});

				return placeholder;
			}
	
	*/
/*scene.add( makePlatform(
				'src/models/platform/platform.json',
				'src/models/platform/platform.jpg',
				renderer.getMaxAnisotropy()
			));

  */ 	 
 
  var text = textureLoader.load( "src/images/rotate_icon.jpg" );
  var text1 = textureLoader.load( "src/images/cluster_toggle.png" );
  var text2 = textureLoader.load( "src/images/visible_toggle.png" );
  var text3 = textureLoader.load( "src/images/fov_toggle.png" );
  var text4 = textureLoader.load( "src/images/position_toggle.jpg" );
  
  //var geom = new THREE.BoxBufferGeometry( 0.05,0.05,0);
  var geom = new THREE.CircleBufferGeometry( 0.015, 32 );
  var mat = new THREE.MeshBasicMaterial( {map:text, wireframe:false, color: 0xd62d20} );
  var mat1 = new THREE.MeshBasicMaterial( {map:text1, wireframe:false, color:0x008744} );
  var mat2 = new THREE.MeshBasicMaterial( { map:text2, wireframe:false,color:0x008744} );
  var mat3 = new THREE.MeshBasicMaterial( { map:text3, wireframe:false, color:0x008744} );
  var mat4 = new THREE.MeshBasicMaterial( { map:text4, wireframe:false, color:0xb3cde0} );
   
  rotationToggle = new THREE.Mesh( geom, mat );

  // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( rotationToggle, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,
		onGazeLong: function(){
			setTimeout(timeout, 600);
			
			if(checkRotate)
			{ checkRotate = false;
			  parameters.rot = false;
		       rotationToggle.material.color.setHex(0xd62d20);
			}
			else {	
			rotationToggle.material.color.setHex(0x008744);
			checkRotate = true;
			parameters.rot = true;
				    
				}
	
		
			// do something user targets object for specific time
			
		}
	});

	
  scene.add( rotationToggle );

  clusterToggle = new THREE.Mesh( geom, mat1 );
  // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( clusterToggle, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,
	
		onGazeLong: function(){
			// do something user targets object for specific time
		      setTimeout(timeout, 600);
			
		
			  if(clusterParticles.visible){
            
			  parameters.cs = false;
              clusterParticles.visible = false;
		      clusterToggle.material.color.setHex(0xd62d20);
			  }
			  else {
			  clusterToggle.material.color.setHex(0x008744);
			  parameters.cs = true;
              clusterParticles.visible = true;
			  }
		
		
        
		}

	});

scene.add( clusterToggle );

 visibleToggle = new THREE.Mesh( geom, mat2 );
  // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( visibleToggle, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,

		onGazeLong: function(){

			      setTimeout(timeout, 600);
           // do something user targets object for specific time
              if(visibleParticles.visible){
      
			  parameters.se = false;
              visibleParticles.visible = false;
			visibleToggle.material.color.setHex(0xd62d20);
			  }
			  else {
	
			  parameters.se = true;
              visibleParticles.visible = true;
			 visibleToggle.material.color.setHex(0x008744);
			  }

			
		}
	});

scene.add( visibleToggle );

 fovToggle = new THREE.Mesh( geom, mat3 );
  // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( fovToggle, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,

		onGazeLong: function(){
		 setTimeout(timeout, 600);
			// do something user targets object for specific time
		if(parameters.wfov) {
				fovToggle.material.color.setHex(0xd62d20);
				parameters.wfov = false;
				parameters.hfov = true;
				TweenLite.to(camera, 1, {fov: FOV_HUMAN, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_HUMAN;
        }});
		}
		else{
				fovToggle.material.color.setHex(0x008744);
				parameters.hfov = false;
				parameters.wfov = true;
				TweenLite.to(camera, 1, {fov: FOV_WIDE, onUpdate: function() {
					camera.updateProjectionMatrix();
				}, onComplete: function() {
				rotateAngle = ROTATE_ANGLE_WIDE;
        }});
		
		}
		}
	});

scene.add( fovToggle );

 positionToggle = new THREE.Mesh( geom, mat4 );
  // *******************************
	// --- Reticulum ---
	// have the object react when user looks at it
	// track the object
	Reticulum.add( positionToggle, {
		reticleHoverColor: 0x00fff6,
		fuseVisible: true,
		
		onGazeLong: function(){
				setTimeout(timeout, 600);
			// do something user targets object for specific time
			if (parameters.zz == true)
			{
				//alert("haa");
				positionToggle.material.color.setHex(0x6497b1);
				parameters.zz = false;
				parameters.z5 = true;
				parameters.z10 = false;
				flyTo(new THREE.Vector3(0, 0, 5));
			}
			else if(parameters.z5 == true)
			{
				positionToggle.material.color.setHex(0x005b96);
				parameters.zz = false;
				parameters.z5 = false;
				parameters.z10 = true;
				flyTo(new THREE.Vector3(0, 0, 10));
			
			}
			else if(parameters.z10 == true)
			{		
				positionToggle.material.color.setHex(0xb3cde0);
				parameters.zz = true;
				parameters.z5 = false;
				parameters.z10 = false;
				flyTo(new THREE.Vector3(0, 0, 0));
			
			}
	  
		}
	});

    scene.add( positionToggle );

    
   rotationToggle.visible = false;
   rotationToggle.position.set(0,-0.2,-0.16);	
   rotationToggle.rotateOnAxis( new THREE.Vector3(1,0,0), - Math.PI / 2);

   clusterToggle.visible = false;
   clusterToggle.position.set(-0.06,-0.20,-0.16);	//initial bevel for cluster toggle set	
   clusterToggle.rotateOnAxis( new THREE.Vector3(1,0,0), - Math.PI / 2);

   visibleToggle.visible = false;
   visibleToggle.position.set(-0.12,-0.20,-0.16);
   visibleToggle.rotateOnAxis( new THREE.Vector3(1,0,0), - Math.PI / 2);

   fovToggle.visible = false;
   fovToggle.position.set(0.06,-0.2,-0.16);	
   fovToggle.rotateOnAxis( new THREE.Vector3(1,0,0), - Math.PI / 2);

   positionToggle.visible = false;
   positionToggle.position.set(0.12,-0.2,-0.16);	
   positionToggle.rotateOnAxis( new THREE.Vector3(1,0,0), - Math.PI / 2);
   
   /*
   // set up rendererCss;
	var rendererCss		= mixerContext.rendererCss;
	rendererCss.setSize( window.innerWidth, window.innerHeight );
	// set up rendererWebgl
	var rendererWebgl	= mixerContext.rendererWebgl;
	var css3dElement		= rendererCss.domElement;
	css3dElement.style.position	= 'absolute';
	css3dElement.style.top		= '0px';
	css3dElement.style.width	= '100%';
	css3dElement.style.height	= '100%';
	document.body.appendChild( css3dElement );
	
	var webglCanvas			= renderer.domElement;
	webglCanvas.style.position	= 'absolute';
	webglCanvas.style.top		= '0px';
	webglCanvas.style.width		= '100%';
	webglCanvas.style.height	= '100%';
	webglCanvas.style.pointerEvents	= 'none';
	css3dElement.appendChild( webglCanvas );
var url		= 'http://threejs.org/';
	var domElement	= document.createElement('iframe');
	domElement.src	= url;
	domElement.style.border	= 'none';
	// create the plane
	var mixerPlane	= new THREEx.HtmlMixer.Plane(mixerContext, domElement);
	mixerPlane.object3d.scale.multiplyScalar(2);
	scene.add(mixerPlane.object3d);*/

function detectmob() { 

   if(window.innerWidth <= 800 && window.innerHeight <= 600) {
     return true;
   } else {
     return false;
   }

}
var check = detectmob();
if (check == true)
{
	document.getElementById('controls').style.display = 'none';
}
	document.body.appendChild( renderer.domElement );
	
	
	
	

	// Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          //controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);
		
	
    /*colorScale = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);*/

    colorScaleRed = chroma.scale(['lightyellow', 'peachpuff', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleWhite = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleBlue = chroma.scale(['lightcyan', 'lightsteelblue', 'black'])
        .domain([-9, -1, 6.5]);

  
    window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('orientationchange', onWindowResize, false);
    
    
}

function onWindowResize()
{

    camera.aspect = window.innerWidth/window.innerHeight;
		//mixerContext.rendererCss.setSize( window.innerWidth, window.innerHeight );
	//Incomplete fix for loading bar resize fix
	/* if(loadFin == false)
	{
     
	document.getElementById( "progressbar" ).style.width = camera.aspect/4 + "px";;
	document.getElementById( "progressbar" ).style.height = camera.aspect/4 * 0.05  + "px";;
	location.reload();
	
	}
	*/
	


	
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
	

}
function timeout()
		{
			rotationToggle.visible = false;
			clusterToggle.visible = false;
			visibleToggle.visible = false;
			fovToggle.visible = false;
			positionToggle.visible = false;
			
		}

function createGeometry(data, name) {



   var geometry = new THREE.Geometry(),
        size = 0.007,
        material,
		sprite,sprite1,
        particles,
		parameters,
        color;
		
   /* var shaderMaterial = new THREE.ShaderMaterial( {
				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true
			});

	*/
	//alert(shaderMaterial);
	
	
   var textureLoader = new THREE.TextureLoader();

   sprite1 = textureLoader.load( "src/images/test_b_alpha.jpg" );
   sprite1.minFilter = THREE.LinearFilter;
   sprite1.anisotropy = renderer.getMaxAnisotropy;
		
    var array = new Float32Array(data.length * 3);
    var colors = new Float32Array(data.length * 3);
	
	if (name == "cluster")total = data.length;
    for (var i = 0,i3=0; i < data.length; i++,i3+=3) {
        
		var vertex = new THREE.Vector3();
		
	
		
        if(name == "cluster"){   
		vertex.x = data[i].X ;
		vertex.y = data[i].Y ;
	
      	vertex.z = data[i].Z ;
		loaded = loaded+1;
	    }
		else{
		vertex.x = data[i].X ;
		vertex.y = data[i].Y ; 
	
      	vertex.z = data[i].Z ;
		
		
		}
	    /*
	  if (name == "cluster")
	{
	    vertex.multiplyScalar();
    } 	*/	
	
	
	
		array[i3+0] = vertex.x;
		array[i3+1] = vertex.y;
		array[i3+2] = vertex.z;
		
        geometry.vertices.push( vertex );

	
        color = calculateColor(data[i]);
	    colors[i3+0] = color.r;
		colors[i3+1] = color.g;
		colors[i3+2] = color.b;
        geometry.colors.push( color );
		
    }
	
	if(name == "cluster") {
	if(loaded == total) {complete = true;loadingFinished();}
	}
	//alert(complete);
	//console.log(array);
	//console.log(colors);
	
// Check browser support
    if (typeof(Storage) !== "undefined") {
    // Store
  
    var visibleArray = localStorage.getItem("visibleArray");
	if(visibleArray == null)
	  localStorage.setItem("visibleArray", array);
	  
	
    } else {
     console.log("Sorry, your browser does not support Web Storage...");
    }


	material = new THREE.PointsMaterial( { size: size,map: sprite1,sizeAttenuation:true, depthTest: false, blending: THREE.AdditiveBlending,transparent: true,  vertexColors: THREE.VertexColors} );
	
    particles = new THREE.Points( geometry, material);
	//particles.renderOrder = 1000;
	
	 particles.name = name;
	//particles.scale.set(6,6,6);
	//particles.translateZ(2);
	scene.add( particles );

				
    if (name === 'visible') {
        visibles = data;
        visibleParticles = particles;
    } else if (name === 'cluster') {
        clusters = data;
        clusterParticles = particles;
    }
}

    function animate() {

	// *******************************
	// --- Reticulum ---
	// keep checking if user is looking at any tracked objects
	Reticulum.update();

    var delta = clock.getDelta(); // seconds.
/*	var moveDistance = 200 * delta; // 200 pixels per second
	var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
	if ( keyboard.pressed("A") )
		rotationToggle.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
	if ( keyboard.pressed("R") )
		rotationToggle.rotateOnAxis( new THREE.Vector3(-1,0,0), rotateAngle);	
*/  

    requestAnimationFrame( animate );
 	  
    controls.update();
	
	stats.update();
	
    if(complete == false){


	
	bar = bar + 4;
	document.getElementById( "bar" ).style.width = bar + "px";

	}
	
   render();
}

function render() {
    if (checkRotate) {
	
	    skybox.rotateOnAxis(ROTATE_AXIS, rotateAngle);
        visibleParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
        clusterParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
		 
    }
	
	

  /*var clock = new THREE.Clock(),
       delta = clock.getDelta(); 

   earthMesh.rotation.y += 1* delta;
    */
effect.render(scene, camera);
	
	
	
}

/**
 * Calculate the apparent magnitude and color mapping of the star
 * @param star
 */
function calculateColor(star) {
    var distance = {}, m, color;

    distance.x = star.X - camera.position.x;
    distance.y = star.Y - camera.position.y;
    distance.z = star.Z - camera.position.z;
    distance.total = Math.sqrt(Math.pow(distance.x, 2) +
                               Math.pow(distance.y, 2) +
                               Math.pow(distance.z, 2));

    m = star.M - 5 * (1 - Math.log10(distance.total));

    //color = colorScale(m).gl();

    if (star.T < 4000) {
        color = colorScaleRed(m).gl();
    } else if (star.T > 10000) {
        color = colorScaleBlue(m).gl();
    } else {
        color = colorScaleWhite(m).gl();
    }

    return new THREE.Color(color[0], color[1], color[2]);
}

/**
 * Move camera to the given location
 * @param location
 */
function flyTo(location) {
    // fly to new position
    var oldPosition = camera.position;
    camera.position.set(location.x, location.y, location.z);

    // calculate new m and colors
    /*for (var i = 0, l = visibleParticles.geometry.colors.length; i < l; i++) {
        visibleParticles.geometry.colors[i] = calculateColor(visibles[i]);
    }*/

    for (var j = 0, m = clusterParticles.geometry.colors.length; j < m; j++) {
        clusterParticles.geometry.colors[j] = calculateColor(clusters[j]);
    }

    visibleParticles.geometry.colorsNeedUpdate = true;
    clusterParticles.geometry.colorsNeedUpdate = true;

    // set new rotation origin
    visibleParticles.position.set(location.x, location.y, oldPosition.z - location.z);
    /*visibleParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);*/

    clusterParticles.position.set(location.x, location.y,oldPosition.z - location.z);
    clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);
}

})();

		</script>
	


</html>
