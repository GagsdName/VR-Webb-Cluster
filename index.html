<!DOCTYPE html>

<html lang="en">
<head>
<title>Webb-Cluster</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="stylesheet" href="src/css/main.css">
	

</head>

<body>
	
         
<!--[if lt IE 10]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->



</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.1.1/chroma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
<script src="src/js/vendor/three.min.js"></script>
<script src="src/js/vendor/TweenLite.min.js"></script>


<script src="src/js/controls/DeviceOrientationControls.js"></script>
<script src="src/js/effects/StereoEffect.js"></script>

<script src="src/js/stats.js"></script>
<script src="src/js/DAT.gui.js"></script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
	<script src="node_modules/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>


<script src="node_modules/three/examples/js/materials/ShadowMaterial.js"></script>

<script src="node_modules/three/examples/js/controls/TrackballControls.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
</script>
<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
 <script>
(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-XXXXX-X');ga('send','pageview');
</script>

<script>
		(function() {

var scene,
    camera,
    renderer,
	effect,
	stats,
	gui,
	earthMesh,
	params,
	platform,
	skybox,
	manager,
	uniforms,
    cameraControls,
    //colorScale,
    colorScaleRed,
    colorScaleWhite,
    colorScaleBlue,
    controls,
    visibles,
    visibleParticles,
    clusters,
    clusterParticles,
    checkRotate = false,
    FOV_HUMAN = 27,
    FOV_WIDE = 75,
    ROTATE_ANGLE_HUMAN = 0.001,
    ROTATE_ANGLE_WIDE = 0.003,
    ROTATE_AXIS = new THREE.Vector3(1, 0, 0),
    rotateAngle;
	

var clock = new THREE.Clock();

init();

animate();

Papa.parse('src/data/movie.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
	
        createGeometry(results.data, 'cluster');
    }
});

Papa.parse('src/data/visible.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
        createGeometry(results.data, 'visible');
    }
});



function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(FOV_WIDE,
                                         window.innerWidth / window.innerHeight,
                                         0.1,
                                         20000);

    rotateAngle = ROTATE_ANGLE_HUMAN;
  
	//camera.position.set(0,6,0);
 	//camera.position.y = 200000;
    //camera.setLens(12);
  
   
    renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.sortObjects = true;

     // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
	//alert(effect);
    effect.setSize(window.innerWidth, window.innerHeight);	
   
   
	
	// Create a VR manager helper to enter and exit VR mode.
    params = {
    hideButton: false, // Default: false.
    isUndistorted: false // Default: false.
    };

	 manager = new WebVRManager(renderer, effect, params);
	//alert(manager);
	
	// Apply VR headset positional data to camera.
    controls = new THREE.VRControls(camera);
	//controls.standing = true;
	
    stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	  document.body.appendChild( stats.domElement );
	  
     //////////////////////
	// GUI Toggle-Panel //
	/////////////////////
	
	gui = new dat.GUI();
	parameters = 
	{ se: true, cs: true, mv: true, plt: true, rot: false, hfov: false, wfov: true, zz: true, z5: false, z10: false,  color: "#ffff00" };
	

	 
	var folder1 = gui.addFolder('Toggle Features');
	
	var seGUI = folder1.add( parameters, 'se' ).name("Earth visible stars").listen();
	seGUI.onChange( function(value) { 
	 visibleParticles.visible = value;
	
	});
	var csGUI = folder1.add( parameters, 'cs' ).name("Cluster stars").listen();
	csGUI.onChange( function(value) { 
    
	clusterParticles.visible = value;
	
	});
	
    var rotGUI = folder1.add( parameters, 'rot' ).name("Rotate").listen();
	rotGUI.onChange( function(value) { 
	  checkRotate = value;
	
	});
	
	var mvGUI = folder1.add( parameters, 'mv' ).name("Earth").listen();
	mvGUI.onChange( function(value) { 
	earthMesh.visible = value;
	
	});
	
	var pltGUI = folder1.add( parameters, 'plt' ).name("Platform").listen();
	pltGUI.onChange( function(value) { 
	platform.visible = value;
	
	});
 
	
	var folder2 = gui.addFolder('Toggle Field of View');
	var hfovGUI = folder2.add( parameters, 'hfov' ).name("Human View").listen();
	hfovGUI.onChange( function(value) { 
	parameters.wfov = false;
	parameters.hfov = true;
	  TweenLite.to(camera, 1, {fov: FOV_HUMAN, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_HUMAN;
        }});
	
	});
	
	var wfovGUI = folder2.add( parameters, 'wfov' ).name("Wide View").listen();
	wfovGUI.onChange( function(value) { 
	
	parameters.hfov = false;
	parameters.wfov = true;
	 TweenLite.to(camera, 1, {fov: FOV_WIDE, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_WIDE;
        }});
	
	});
	


	
	
	var folder3 = gui.addFolder('Toggle Position');
	var zzGUI = folder3.add( parameters, 'zz' ).name("(0 0 0)").listen();
	zzGUI.onChange( function(value) { 
	  parameters.zz = true;
      parameters.z5 = false;
	  parameters.z10 = false;
	  flyTo(new THREE.Vector3(0, 0, 0));
	});
	
	var z5 = folder3.add( parameters, 'z5' ).name("(0,0,5 pc)").listen();
	z5.onChange( function(value) { 
	  parameters.zz = false;
      parameters.z5 = true;
	  parameters.z10 = false;
	  flyTo(new THREE.Vector3(0, 0, 5));
	});
	
	var z10 = folder3.add( parameters, 'z10' ).name("(0,0,10 pc)").listen();
	z10.onChange( function(value) { 
	 parameters.zz = false;
      parameters.z5 = false;
	  parameters.z10 = true;
	  flyTo(new THREE.Vector3(0, 0, 10));
	});
	

	

	
 
	

/*var tempGeometry   = new THREE.SphereGeometry(32, 32, 32);
var tempMaterial  = new THREE.MeshPhongMaterial({color:0x000000, wireframe: true});
var tempMesh = new THREE.Mesh(tempGeometry, tempMaterial);
scene.add(tempMesh);
*/

    var geometry = new THREE.SphereGeometry(500,60,40);

	var material = new THREE.MeshBasicMaterial();
    material.map = THREE.ImageUtils.loadTexture('src/images/360.jpg');
    material.side = THREE.BackSide;

	var textureLoader = new THREE.TextureLoader();

    var earth = textureLoader.load( 'src/images/earthmap1k.jpg' );

	earthMesh = new THREE.Mesh(
					new THREE.SphereBufferGeometry(0.5, 32, 32 ),
					new THREE.MeshBasicMaterial( {  map: earth, blending: THREE.AdditiveBlending} )
				);

	earthMesh.position.set(0, -2, 0);
    scene.add( earthMesh );

   skybox = new THREE.Mesh(geometry, material);
    scene.add(skybox);
	
	
		function makePlatform( jsonUrl, textureUrl, textureQuality ) {
				var placeholder = new THREE.Object3D();

				var texture = new THREE.TextureLoader().load( textureUrl );
				texture.minFilter = THREE.LinearFilter;
				texture.anisotropy = textureQuality;

				var loader = new THREE.JSONLoader();
				loader.load( jsonUrl, function( geometry ) {

			    geometry.computeFaceNormals();
                //geometry.applyMatrix( new THREE.Matrix4().makeTranslation(0, 0, 60) );
			    platform = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({ map : texture }) );
				//platform.renderOrder = 100;
                    //platform.position = new THREE.Vector3(0, -30, 0)
					//platform.material.polygonOffset = true;
                    //platform.material.polygonOffsetFactor = -0.1;
					//platform.position = new THREE.Vector3(0,0,1000) ; //see position is Vector3()
               platform.position.set(0, -2, 0);
			   //platform.translateZ();
               //clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        //oldPosition.y - location.y,
                                        //oldPosition.z - location.z);
          
					
					platform.name = "platform";

					placeholder.add( platform );
					
					//placeholder.position = new THREE.Vector3(0,0,-10000);
				});

				return placeholder;
			}
	
	
	
	
	scene.add( makePlatform(
				'src/models/platform/platform.json',
				'src/models/platform/platform.jpg',
				renderer.getMaxAnisotropy()
			));
		
	
	
	
    document.body.appendChild( renderer.domElement );
	
	   

	// Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          //controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);
		
	
    /*colorScale = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);*/

    colorScaleRed = chroma.scale(['lightyellow', 'peachpuff', 'white'])
        .domain([-9, -1, 6.5]);

    colorScaleWhite = chroma.scale(['white', 'gainsboro', 'white'])
        .domain([-9, -1, 6.5]);

    colorScaleBlue = chroma.scale(['lightcyan', 'lightsteelblue', 'white'])
        .domain([-9, -1, 6.5]);

  
    
    
    
}

function createGeometry(data, name) {



   var geometry = new THREE.Geometry(),
        size = 0.3,
        material,
		sprite,sprite1,
        particles,
		parameters,
        color;
		
	
   var textureLoader = new THREE.TextureLoader();

   sprite1 = textureLoader.load( "src/images/circle_white.png" );
   sprite1.minFilter = THREE.LinearFilter;
   sprite1.anisotropy = renderer.getMaxAnisotropy;
		
    var array = new Float32Array(data.length * 3);
    var colors = new Float32Array(data.length * 3);
    for (var i = 0,i3=0; i < data.length; i++,i3+=3) {
        
		var vertex = new THREE.Vector3();
		
	
		
    
		vertex.x = data[i].X * 500;
		vertex.y = data[i].Y * 500 ;
	
      	vertex.z = data[i].Z * 500;
	    
	    /*
	  if (name == "cluster")
	{
	    vertex.multiplyScalar();
    } 	*/	
	
	
	
		array[i3+0] = vertex.x;
		array[i3+1] = vertex.y;
		array[i3+2] = vertex.z;
		
        geometry.vertices.push( vertex );

	
        color = calculateColor(data[i]);
	    colors[i3+0] = color.r;
		colors[i3+1] = color.g;
		colors[i3+2] = color.b;
        geometry.colors.push( color );
    }
	
	//console.log(array);
	//console.log(colors);
	
// Check browser support
    if (typeof(Storage) !== "undefined") {
    // Store
  
    var visibleArray = localStorage.getItem("visibleArray");
	if(visibleArray == null)
	  localStorage.setItem("visibleArray", array);
	  
	
    } else {
     console.log("Sorry, your browser does not support Web Storage...");
    }


	material = new THREE.PointsMaterial( { size: size, map: sprite1, sizeAttenuation: false, depthTest: true, blending: THREE.AdditiveBlending, transparent : true,  vertexColors: THREE.VertexColors } );
	
    particles = new THREE.Points( geometry, material);
	//particles.renderOrder = 1000;
	
	 particles.name = name;
	//particles.scale.set(6,6,6);
	//particles.translateZ(2);
	scene.add( particles );

				
    if (name === 'visible') {
        visibles = data;
        visibleParticles = particles;
    } else if (name === 'cluster') {
        clusters = data;
        clusterParticles = particles;
    }
}

function animate() {


var delta = clock.getDelta();
    requestAnimationFrame( animate );
 
    controls.update(delta);
	stats.update();
   // camera.updateProjectionMatrix();   
   render();
}

function render() {
    if (checkRotate) {
        visibleParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
        clusterParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
		 
    }

  /*var clock = new THREE.Clock(),
       delta = clock.getDelta(); 

   earthMesh.rotation.y += 1* delta;
    */
	effect.render(scene, camera);
	
	
	
}

/**
 * Calculate the apparent magnitude and color mapping of the star
 * @param star
 */
function calculateColor(star) {
    var distance = {}, m, color;

    distance.x = star.X - camera.position.x;
    distance.y = star.Y - camera.position.y;
    distance.z = star.Z - camera.position.z;
    distance.total = Math.sqrt(Math.pow(distance.x, 2) +
                               Math.pow(distance.y, 2) +
                               Math.pow(distance.z, 2));

    m = star.M - 5 * (1 - Math.log10(distance.total));

    //color = colorScale(m).gl();

    if (star.T < 4000) {
        color = colorScaleRed(m).gl();
    } else if (star.T > 10000) {
        color = colorScaleBlue(m).gl();
    } else {
        color = colorScaleWhite(m).gl();
    }

    return new THREE.Color(color[0], color[1], color[2]);
}

/**
 * Move camera to the given location
 * @param location
 */
function flyTo(location) {
    // fly to new position
    var oldPosition = camera.position;
    camera.position.set(location.x, location.y, location.z);

	
    // calculate new m and colors
    /*for (var i = 0, l = visibleParticles.geometry.colors.length; i < l; i++) {
        visibleParticles.geometry.colors[i] = calculateColor(visibles[i]);
    }*/

    for (var j = 0, m = clusterParticles.geometry.colors.length; j < m; j++) {
        clusterParticles.geometry.colors[j] = calculateColor(clusters[j]);
    }

    visibleParticles.geometry.colorsNeedUpdate = true;
    clusterParticles.geometry.colorsNeedUpdate = true;
    //visibleParticles.material.needsUpdate = true;
	//clusterParticles.material.needsUpdate = true;
    // set new rotation origin
    visibleParticles.position.set(location.x, location.y, location.z);
    /*visibleParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);*/

    clusterParticles.position.set(location.x, location.y, location.z);
    clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);
}

})();

		</script>
	


</html>
