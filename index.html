<!DOCTYPE html>

<html lang="en">
<head>
<title>Webb-Cluster</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="stylesheet" href="src/css/main.css">
	

</head>

<body onload="foo()">
	
         
<!--[if lt IE 10]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->



</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.1.1/chroma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
<script src="src/js/vendor/three.min.js"></script>
<script src="src/js/vendor/TweenLite.min.js"></script>


<script src="src/js/controls/DeviceOrientationControls.js"></script>
<script src="src/js/effects/StereoEffect.js"></script>

<script src="src/js/stats.js"></script>
<script src="src/js/DAT.gui.js"></script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
	<script src="node_modules/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>


<script src="node_modules/three/examples/js/materials/ShadowMaterial.js"></script>

<script src="node_modules/three/examples/js/controls/TrackballControls.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
		</script>
<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
 <script>
(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-XXXXX-X');ga('send','pageview');
</script>

<script>
		(function() {

var scene,
    camera,
    renderer,
	effect,
	stats,
	gui,
	earthMesh,
	params,
	manager,
	uniforms,
    cameraControls,
    //colorScale,
    colorScaleRed,
    colorScaleWhite,
    colorScaleBlue,
    controls,
    visibles,
    visibleParticles,
    clusters,
    clusterParticles,
    checkRotate = false,
    FOV_HUMAN = 27,
    FOV_WIDE = 75,
    ROTATE_ANGLE_HUMAN = 0.001,
    ROTATE_ANGLE_WIDE = 0.003,
    ROTATE_AXIS = new THREE.Vector3(1, 0, 0),
    rotateAngle;
	

var clock = new THREE.Clock();

init();

animate();

Papa.parse('src/data/movie.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
	
        createGeometry(results.data, 'cluster');
    }
});

Papa.parse('src/data/visible.csv', {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function (results) {
        createGeometry(results.data, 'visible');
    }
});



function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(FOV_WIDE,
                                         window.innerWidth / window.innerHeight,
                                         0.1,
                                         10000000);

    rotateAngle = ROTATE_ANGLE_HUMAN;

 
    //camera.setLens(300);
    camera.position.z = 320;
   
    renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( window.innerWidth, window.innerHeight );


     // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
	//alert(effect);
    effect.setSize(window.innerWidth, window.innerHeight);	
   
   // effect = new THREE.StereoEffect( renderer );
	//alert(effect);
	//effect.setSize( window.innerWidth, window.innerHeight );
	
	
	// Create a VR manager helper to enter and exit VR mode.
    params = {
    hideButton: false, // Default: false.
    isUndistorted: false // Default: false.
    };

	 manager = new WebVRManager(renderer, effect, params);
	//alert(manager);
	
	// Apply VR headset positional data to camera.
    controls = new THREE.VRControls(camera);
	controls.standing = true;
	
    stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	  document.body.appendChild( stats.domElement );
	  
/////////
	// GUI //
	/////////
	
	gui = new dat.GUI();
	parameters = 
	{ se: true, cs: true, mv: true,rot: false, hfov: false, wfov: true, zz: true, z5: false, z10: false,  color: "#ffff00" };
	

	 
	var folder1 = gui.addFolder('Toggle Features');
	
	var seGUI = folder1.add( parameters, 'se' ).name("Earth visible stars").listen();
	seGUI.onChange( function(value) { 
	 visibleParticles.visible = value;
	
	});
	var csGUI = folder1.add( parameters, 'cs' ).name("Cluster stars").listen();
	csGUI.onChange( function(value) { 
    
	clusterParticles.visible = value;
	
	});
	
    var rotGUI = folder1.add( parameters, 'rot' ).name("Rotate").listen();
	rotGUI.onChange( function(value) { 
	  checkRotate = value;
	
	});
	
	var mvGUI = folder1.add( parameters, 'mv' ).name("Earth").listen();
	mvGUI.onChange( function(value) { 
	earthMesh.visible = value;
	
	});
    folder1.open();
	
	var folder2 = gui.addFolder('Toggle Field of View');
	var hfovGUI = folder2.add( parameters, 'hfov' ).name("Human View").listen();
	hfovGUI.onChange( function(value) { 
	parameters.wfov = false;
	parameters.hfov = true;
	  TweenLite.to(camera, 1, {fov: FOV_HUMAN, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_HUMAN;
        }});
	
	});
	
	var wfovGUI = folder2.add( parameters, 'wfov' ).name("Wide View").listen();
	wfovGUI.onChange( function(value) { 
	
	parameters.hfov = false;
	parameters.wfov = true;
	 TweenLite.to(camera, 1, {fov: FOV_WIDE, onUpdate: function() {
            camera.updateProjectionMatrix();
        }, onComplete: function() {
            rotateAngle = ROTATE_ANGLE_WIDE;
        }});
	
	});
	
	folder2.open();

	
	
	var folder3 = gui.addFolder('Toggle Position');
	var zzGUI = folder3.add( parameters, 'zz' ).name("(0 0 0)").listen();
	zzGUI.onChange( function(value) { 
	  parameters.zz = true;
      parameters.z5 = false;
	  parameters.z10 = false;
	  flyTo(new THREE.Vector3(0, 0, 0));
	});
	
	var z5 = folder3.add( parameters, 'z5' ).name("(0,0,5 pc)").listen();
	z5.onChange( function(value) { 
	  parameters.zz = false;
      parameters.z5 = true;
	  parameters.z10 = false;
	  flyTo(new THREE.Vector3(0, 0, 5));
	});
	
	var z10 = folder3.add( parameters, 'z10' ).name("(0,0,10 pc)").listen();
	z10.onChange( function(value) { 
	 parameters.zz = false;
      parameters.z5 = false;
	  parameters.z10 = true;
	  flyTo(new THREE.Vector3(0, 0, 10));
	});
	
	folder3.open();
	// cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
    // cameraControls.target.set(0, 0, 0);
				
    /*var freefly = document.getElementbyId('freefly');
	alert(freefly);
	if(freefly.checked)
	{controls.standing = true; controls.update();}*/

	
    var textureLoader = new THREE.TextureLoader();

    var earth = textureLoader.load( 'src/images/earthmap1k.jpg' );
	//var spec = textureLoader.load('src/images/earthspec1k.jpg');
	earthMesh = new THREE.Mesh(
					new THREE.SphereBufferGeometry(0.5, 32, 32 ),
					new THREE.MeshBasicMaterial( {  map: earth, blending: THREE.AdditiveBlending} )
				);

	
    scene.add( earthMesh );
	



    document.body.appendChild( renderer.domElement );

	// Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          //controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);
		
	
    /*colorScale = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);*/

    colorScaleRed = chroma.scale(['lightyellow', 'peachpuff', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleWhite = chroma.scale(['white', 'gainsboro', 'black'])
        .domain([-9, -1, 6.5]);

    colorScaleBlue = chroma.scale(['lightcyan', 'lightsteelblue', 'black'])
        .domain([-9, -1, 6.5]);

  
    
    
    
}

function createGeometry(data, name) {



   var geometry = new THREE.Geometry(),
        size = 0.016,
        material,
		sprite,sprite1,
        particles,
		parameters,
        color;
		
		


    var textureLoader = new THREE.TextureLoader();

    sprite1 = textureLoader.load( "src/images/flare16.jpg" );
var array = new Float32Array(data.length * 3);
var colors = new Float32Array(data.length * 3);
    for (var i = 0,i3=0; i < data.length; i++,i3+=3) {
        
		var vertex = new THREE.Vector3();
		
        vertex.x = data[i].X;
        vertex.y = data[i].Y;
        vertex.z = data[i].Z;
		
		array[i3+0] = vertex.x;
		array[i3+1] = vertex.y;
		array[i3+2] = vertex.z;
		
        geometry.vertices.push( vertex );

	
        color = calculateColor(data[i]);
	    colors[i3+0] = color.r;
		colors[i3+1] = color.y;
		colors[i3+2] = color.z;
        geometry.colors.push( color );
    }
	
	//console.log(array);
	//console.log(colors);
	
// Check browser support
if (typeof(Storage) !== "undefined") {
    // Store
  
    var visibleArray = localStorage.getItem("visibleArray");
	if(visibleArray == null)
	  localStorage.setItem("visibleArray", array);
	
} else {
     console.log("Sorry, your browser does not support Web Storage...");
}


	material = new THREE.PointsMaterial( { size: size, sizeAttenuation: true, map: sprite1, depthTest: false, blending: THREE.AdditiveBlending, transparent : true,  vertexColors: THREE.VertexColors } );
	
   
    particles = new THREE.Points( geometry, material);
	 particles.name = name;
	scene.add( particles );

				
    if (name === 'visible') {
        visibles = data;
        visibleParticles = particles;
    } else if (name === 'cluster') {
        clusters = data;
        clusterParticles = particles;
    }
}

function animate() {


var delta = clock.getDelta();
    requestAnimationFrame( animate );
 
    controls.update(delta);
	stats.update();
  // cameraControls.update(delta);
    render();
}

function render() {
    if (checkRotate) {
        visibleParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
        clusterParticles.rotateOnAxis(ROTATE_AXIS, rotateAngle);
    }
  /*var clock = new THREE.Clock(),
       delta = clock.getDelta(); 

   earthMesh.rotation.y += 1* delta;
    */
	effect.render(scene, camera);
	
	
	
}

/**
 * Calculate the apparent magnitude and color mapping of the star
 * @param star
 */
function calculateColor(star) {
    var distance = {}, m, color;

    distance.x = star.X - camera.position.x;
    distance.y = star.Y - camera.position.y;
    distance.z = star.Z - camera.position.z;
    distance.total = Math.sqrt(Math.pow(distance.x, 2) +
                               Math.pow(distance.y, 2) +
                               Math.pow(distance.z, 2));

    m = star.M - 5 * (1 - Math.log10(distance.total));

    //color = colorScale(m).gl();

    if (star.T < 4000) {
        color = colorScaleRed(m).gl();
    } else if (star.T > 10000) {
        color = colorScaleBlue(m).gl();
    } else {
        color = colorScaleWhite(m).gl();
    }

    return new THREE.Color(color[0], color[1], color[2]);
}

/**
 * Move camera to the given location
 * @param location
 */
function flyTo(location) {
    // fly to new position
    var oldPosition = camera.position;
    camera.position.set(location.x, location.y, location.z);

    // calculate new m and colors
    /*for (var i = 0, l = visibleParticles.geometry.colors.length; i < l; i++) {
        visibleParticles.geometry.colors[i] = calculateColor(visibles[i]);
    }*/

    for (var j = 0, m = clusterParticles.geometry.colors.length; j < m; j++) {
        clusterParticles.geometry.colors[j] = calculateColor(clusters[j]);
    }

    visibleParticles.geometry.colorsNeedUpdate = true;
    clusterParticles.geometry.colorsNeedUpdate = true;
    //visibleParticles.material.needsUpdate = true;
	//clusterParticles.material.needsUpdate = true;
    // set new rotation origin
    visibleParticles.position.set(location.x, location.y, location.z);
    /*visibleParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);*/

    clusterParticles.position.set(location.x, location.y, location.z);
    clusterParticles.geometry.translate(oldPosition.x - location.x,
                                        oldPosition.y - location.y,
                                        oldPosition.z - location.z);
}

})();

		</script>
	


</html>
